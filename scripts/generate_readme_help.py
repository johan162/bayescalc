"""Generate a README help section from the COMMANDS descriptor in probs_cli.py.

This script imports the `COMMANDS` list and writes a Markdown snippet to stdout
or to a specified file. It's intentionally small and safe for use in Makefile
recipes.
"""
import argparse
import importlib.util
import inspect
import sys
import os


def load_commands():
    # Load the probs_cli module from the workspace by file path so this script
    # works even if the package is not installed in the environment.
    import importlib.util
    import os

    repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
    probs_cli_path = os.path.join(repo_root, "probs_cli.py")
    if not os.path.exists(probs_cli_path):
        return []

    spec = importlib.util.spec_from_file_location("probs_cli", probs_cli_path)
    module = importlib.util.module_from_spec(spec)
    # Ensure local package imports resolve by temporarily adding repo root to sys.path
    import sys
    sys.path.insert(0, repo_root)
    try:
        spec.loader.exec_module(module)
    finally:
        # Clean up sys.path modifications
        try:
            sys.path.remove(repo_root)
        except Exception:
            pass
    return getattr(module, "COMMANDS", [])


def render_markdown(commands):
    lines = []
    lines.append("## CLI Commands")
    lines.append("")
    lines.append("Below are the supported CLI commands and their arguments:")
    lines.append("")

    for cmd in commands:
        lines.append(f"### `{cmd['cmd']}`")
        lines.append("")
        if "summary" in cmd:
            lines.append(cmd["summary"]) 
            lines.append("")
        if "params" in cmd:
            lines.append("Parameters:")
            lines.append("")
            for p in cmd["params"]:
                lines.append(f"- `{p['name']}`: {p['desc']}")
            lines.append("")
        if "examples" in cmd:
            lines.append("Examples:")
            lines.append("")
            for ex in cmd["examples"]:
                lines.append(f"- `{ex}`")
            lines.append("")
        else:
            # Provide default examples for some known commands if examples not present
            cname = cmd.get("cmd", "").lower()
            defaults = []
            if cname.startswith("odds_ratio") or "odds_ratio(" in cname:
                defaults = ["odds_ratio(A,B)"]
            elif cname.startswith("relative_risk") or "relative_risk(" in cname:
                defaults = ["relative_risk(A,B)"]
            elif cname.startswith("sample") or "sample(" in cname:
                defaults = ["sample", "sample(5)", "sample(n=10)"]

            if defaults:
                lines.append("Examples:")
                lines.append("")
                for ex in defaults:
                    lines.append(f"- `{ex}`")
                lines.append("")
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description="Generate README help section from probs_cli.COMMANDS")
    parser.add_argument("--output", "-o", help="Output file (defaults to stdout)")
    parser.add_argument("--inject", "-i", help="Inject generated section into README file between sentinel markers (path)")
    parser.add_argument("--dry-run", action="store_true", help="When used with --inject, print the would-be injected content and do not write files")
    parser.add_argument("--confirm", action="store_true", help="When used with --inject, prompt for confirmation before writing the README file")
    parser.add_argument("--fail-on-missing-markers", action="store_true",
                        help="If set, abort when the README does not contain the sentinel markers instead of appending the section")
    parser.add_argument("--backup-dir", help="Directory to store README backups instead of placing .bak next to the README")
    args = parser.parse_args()

    commands = load_commands()
    md = render_markdown(commands)

    if args.inject:
        if args.dry_run:
            # Show the would-be resulting file content for inspection
            from io import StringIO
            # Build the injected content the same way inject_into_readme would
            START = "<!-- CLI_HELP_START -->"
            END = "<!-- CLI_HELP_END -->"
            autogenerated_note = (
                "**NOTE:** This section is auto-generated from the source code. "
                "Do not edit it manually; instead update the code or run the generator.\n"
            )
            injected = autogenerated_note + "\n" + md
            with open(args.inject, "r", encoding="utf-8") as f:
                original = f.read()
            has_markers = (START in original and END in original)
            if args.fail_on_missing_markers and not has_markers:
                sys.stderr.write("Error: markers not found in README and --fail-on-missing-markers set\n")
                sys.exit(2)
            if has_markers:
                pre, rest = original.split(START, 1)
                _, post = rest.split(END, 1)
                new = pre + START + "\n" + injected + "\n" + END + post
            else:
                if not original.endswith("\n"):
                    original += "\n"
                new = original + "\n" + START + "\n" + injected + "\n" + END + "\n"
            sys.stdout.write(new)
            return

        if args.confirm:
            ans = input(f"Inject generated CLI help into {args.inject}? [y/N]: ")
            if ans.strip().lower() not in ("y", "yes"):
                print("Aborted by user.")
                return

        inject_into_readme(args.inject, md, fail_on_missing_markers=args.fail_on_missing_markers, backup_dir=args.backup_dir)
        print(f"Injected CLI help into: {args.inject}")
    elif args.output:
        with open(args.output, "w") as f:
            f.write(md)
    else:
        sys.stdout.write(md)


def inject_into_readme(readme_path: str, md_content: str, fail_on_missing_markers: bool = False, backup_dir: str | None = None) -> None:
    """Inject md_content into readme_path between sentinel markers.

    If markers are not present, append the section at the end. A backup of the
    original readme is written to <readme_path>.bak.
    """
    import shutil

    START = "<!-- CLI_HELP_START -->"
    END = "<!-- CLI_HELP_END -->"

    if not os.path.exists(readme_path):
        raise FileNotFoundError(readme_path)

    # Determine backup path
    if backup_dir:
        os.makedirs(backup_dir, exist_ok=True)
        backup_path = os.path.join(backup_dir, os.path.basename(readme_path) + ".bak")
    else:
        backup_path = readme_path + ".bak"
    shutil.copyfile(readme_path, backup_path)

    with open(readme_path, "r", encoding="utf-8") as f:
        original = f.read()

    # Add an auto-generated warning banner inside the markers so humans know
    # not to edit the block directly.
    autogenerated_note = (
        "**NOTE:** This section is auto-generated from the source code. "
        "Do not edit it manually; instead update the code or run the generator.\n"
    )

    injected = autogenerated_note + "\n" + md_content

    has_markers = (START in original and END in original)
    if fail_on_missing_markers and not has_markers:
        raise RuntimeError("Markers not found in README and --fail-on-missing-markers set")

    if has_markers:
        pre, rest = original.split(START, 1)
        _, post = rest.split(END, 1)
        new = pre + START + "\n" + injected + "\n" + END + post
    else:
        # Append at end with markers
        if not original.endswith("\n"):
            original += "\n"
        new = original + "\n" + START + "\n" + injected + "\n" + END + "\n"

    with open(readme_path, "w", encoding="utf-8") as f:
        f.write(new)


if __name__ == "__main__":
    main()
