#!/usr/bin/env python3
"""Generate a public API reference table for ProbabilitySystem.

This script introspects `probs_core.probability.ProbabilitySystem` and builds a
Markdown table summarizing public methods. It then injects the table between
sentinel markers in the specified architecture file (default: ARCHITECTURE.md).

Sentinels:
<!-- API-TABLE:START -->
<!-- API-TABLE:END -->

Usage:
  python scripts/generate_api_reference.py --file ARCHITECTURE.md            # inject/update
  python scripts/generate_api_reference.py --file ARCHITECTURE.md --print    # print table only
  python scripts/generate_api_reference.py --file ARCHITECTURE.md --check    # exit 1 if update needed

Exit codes:
  0 = success / no update needed (in check mode)
  1 = check mode found differences or error occurred
"""
from __future__ import annotations

import argparse
import inspect
import os
import re
import sys
from typing import List, Tuple


SENTINEL_START = "<!-- API-TABLE:START -->"
SENTINEL_END = "<!-- API-TABLE:END -->"
GENERATED_NOTE = "<!-- Generated by scripts/generate_api_reference.py; do not edit manually -->"


def load_probability_system():
    try:
        # Ensure project root (parent directory of scripts/) is on sys.path
        scripts_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.abspath(os.path.join(scripts_dir, '..'))
        if project_root not in sys.path:
            sys.path.insert(0, project_root)
        from probs_core.probability import ProbabilitySystem  # type: ignore
    except Exception as e:  # pragma: no cover
        print(f"Error importing ProbabilitySystem: {e}", file=sys.stderr)
        raise
    return ProbabilitySystem


def iter_public_methods(cls) -> List[Tuple[str, object, str]]:
    """Return list of (name, function_object, kind) in definition order.

    kind: 'instance' | 'class' | 'static'
    """
    items: List[Tuple[str, object, str]] = []
    for name, member in cls.__dict__.items():  # preserves definition order (Py>=3.6)
        if name.startswith("_"):
            continue
        kind = "instance"
        func_obj = member
        if isinstance(member, classmethod):
            kind = "class"
            func_obj = member.__func__
        elif isinstance(member, staticmethod):
            kind = "static"
            func_obj = member.__func__
        if callable(func_obj):
            items.append((name, func_obj, kind))
    return items


def format_signature(func, kind: str) -> str:
    sig = inspect.signature(func)
    params = list(sig.parameters.values())
    if params:
        first = params[0]
        if (kind == "instance" and first.name == "self") or (kind == "class" and first.name == "cls"):
            params = params[1:]
    new_sig = f"({', '.join(str(p) for p in params)})"
    # Add return annotation if present and not empty
    if sig.return_annotation not in (inspect._empty, None):  # type: ignore
        new_sig += f" -> {getattr(sig.return_annotation, '__name__', sig.return_annotation)}"
    return new_sig


def first_line(doc: str | None) -> str:
    if not doc:
        return "(no description)"
    line = doc.strip().splitlines()[0].strip()
    # Collapse internal whitespace
    line = re.sub(r"\s+", " ", line)
    return line


def build_table(cls) -> str:
    rows = []
    rows.append("| Method | Signature | Kind | Description |")
    rows.append("|--------|-----------|------|-------------|")
    for name, func, kind in iter_public_methods(cls):
        try:
            sig = format_signature(func, kind)
        except Exception as e:  # pragma: no cover
            sig = f"(error: {e})"
        desc = first_line(func.__doc__)
        # Escape pipe characters in doc
        desc = desc.replace("|", "\\|")
        rows.append(f"| `{name}` | `{sig}` | {kind} | {desc} |")
    return "\n".join(rows) + "\n"


def inject_table(original: str, table: str) -> str:
    block = f"{SENTINEL_START}\n{GENERATED_NOTE}\n\n{table}{SENTINEL_END}"
    pattern = re.compile(rf"{re.escape(SENTINEL_START)}.*?{re.escape(SENTINEL_END)}", re.DOTALL)
    if pattern.search(original):
        return pattern.sub(block, original)
    # If no sentinel, append near the end (before final line if it says End of Architecture Document.)
    lines = original.rstrip().splitlines()
    inserted = False
    for i, line in enumerate(lines):
        if line.strip().startswith("End of Architecture Document"):
            lines.insert(i, block)
            inserted = True
            break
    if not inserted:
        lines.append("\n## Public API Reference\n")
        lines.append(block)
    return "\n".join(lines) + "\n"


def main():
    parser = argparse.ArgumentParser(description="Generate ProbabilitySystem API reference table")
    parser.add_argument("--file", default="ARCHITECTURE.md", help="Markdown file to update")
    parser.add_argument("--print", action="store_true", dest="do_print", help="Print table only")
    parser.add_argument("--check", action="store_true", help="Exit 1 if the file needs update (CI mode)")
    args = parser.parse_args()

    cls = load_probability_system()
    table = build_table(cls)

    if args.do_print:
        print(table)
        return 0

    try:
        with open(args.file, "r", encoding="utf-8") as f:
            original = f.read()
    except FileNotFoundError:
        print(f"File not found: {args.file}", file=sys.stderr)
        return 1

    updated = inject_table(original, table)
    if args.check:
        if updated != original:
            print("API reference is outdated. Run make api-ref.", file=sys.stderr)
            return 1
        return 0

    if updated != original:
        with open(args.file, "w", encoding="utf-8") as f:
            f.write(updated)
        print(f"Updated {args.file} with API reference table.")
    else:
        print("No changes needed.")
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
